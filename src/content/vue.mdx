# Vue 八股

## 1. Vue 的 MVVM 模式是什么

Model-View-ViewModel 通过数据绑定实现视图与数据的自动同步

- Model :数据层,负责业务逻辑
- View : UI 层,展示数据
- ViewModel :双向绑定桥梁,监听数据变化并更新视图

## 2. diff 算法

1. 同层比较

- Vue 的 diff 算法采用了**同层比较**的方式,这意味着它只会比较同一层级的节点,而不会跨层级进行比较。这种策略减少了不必要的比较次数,提高了效率。

- 为什么选择同层比较？
  - 在实际的网页结构中,跨层级移动元素的情况相对较少,因此专注于同层比较可以覆盖大多数场景,并且显著减少计算量。

2. 双端比较

- 在比较两个虚拟 DOM 节点时,Vue 采用了一种称为**双端比较**的方法。具体来说,它会同时从头部和尾部开始比较新旧节点列表,尽可能快地找到差异。

- 如何工作？
  - 首先尝试匹配旧节点列表的头与新节点列表的头,如果匹配成功,则继续比较下一个。
  - 如果不匹配,则尝试匹配旧节点列表的尾与新节点列表的尾。
  - 若两端都不匹配,则进入更详细的逐个节点比较过程。

3. Key 属性的重要性

   为了优化 diff 过程,Vue 允许为每个节点指定一个唯一的 `key` 属性。当存在 `key` 时,Vue 可以更快地识别哪些节点发生了变化、哪些被添加或删除了,从而更加高效地执行更新。

- 作用:
  - 帮助框架准确识别节点的身份,避免不必要的重排(reordering)和重绘(repainting)。
  - 提高 diff 算法的效率,特别是在动态列表中尤为重要。

4. Patch 更新

   一旦确定了需要更新的部分,Vue 会生成一系列的 patch(补丁),这些 patch 描述了具体的 DOM 操作(如插入、删除、修改属性等)。之后,Vue 会批量执行这些 patch 来同步真实的 DOM 结构。

Vue 3 对其 diff 算法进行了进一步优化:

- 静态树提升:对于那些不会随状态改变而变化的部分(静态子树),Vue 3 会在编译阶段将其标记出来,并在运行时跳过这些部分的 diff 操作,从而减少不必要的计算。
- 静态属性提升:类似于静态树提升,对于静态属性,Vue 3 也会进行优化,减少重复计算。
- Fragment 支持:允许组件返回多个根节点而不必包裹在一个额外的 div 内,简化了模板结构的同时也优化了 diff 算法的表现。

## 3. 响应式原理

## 4. vue 是怎么从入口文件开始渲染文件的

1. 创建一个 vue 的 app 实例,挂载 app 实例到 html 编译成的 DOM 树上
2. `app.mount()` 被调用之后,vue 会从 `App.vue` 开始解析,解析模板成 AST、优化 AST 树、将 AST 转化为渲染函数,返回虚拟 DOM 树
3. 通过虚拟 DOM,Vue 可以在内存中对 DOM 的变化进行计算和比较,避免直接操作真实 DOM 带来的性能损耗。
4. Vue 根据虚拟 DOM 树创建对应的真实 DOM 节点,并将这些节点插入到页面中。这个过程就是首次渲染,用户可以看到页面的初始状态。
5. 响应式更新

- 当组件中的响应式数据发生变化时,Vue 会自动检测到这些变化,并重新计算虚拟 DOM 树。
- 通过比较新旧虚拟 DOM 树的差异,Vue 会只更新需要更新的真实 DOM 节点,从而实现高效的页面更新。

## 5. vite 打包的过程

Vite 是一个轻量级的前端构建工具,在 Vue 应用中使用 Vite 打包,主要有以下几个关键阶段:

### 1. 配置加载

- **读取配置文件**:Vite 会先读取项目根目录下的 `vite.config.js` 或 `vite.config.ts` 文件。在这个文件里,你可以对 Vite 进行各种自定义配置,例如设置基础路径、别名、插件等。

- **应用默认配置**:如果没有提供自定义配置文件,Vite 会使用其内置的默认配置。

### 2. 依赖预构建

- **扫描入口文件**:Vite 会从项目的入口文件(通常是 `main.ts` 或 `main.js`)开始,递归扫描所有导入的模块,找出所有依赖项。
- **构建依赖包**:对于 `node_modules` 中的依赖,Vite 会将它们预先打包成 ES 模块格式。这样做的好处是可以提高开发和生产环境的加载速度,同时避免浏览器对 CommonJS 或 AMD 模块的兼容性问题。
- **缓存处理**:Vite 会将预构建的依赖包缓存起来,下次打包时如果依赖没有变化,就可以直接使用缓存,从而加快打包速度。

### 3. 源码转换

- **模块解析**:Vite 会对项目中的所有源码文件进行解析,将各种模块导入语法(如 ES6 的 `import` 语句)转换为浏览器可以理解的格式。
- **插件处理**:Vite 支持使用插件来扩展其功能。在这个阶段,Vite 会依次调用配置中指定的插件,对源码进行处理。例如,`@vitejs/plugin-vue` 插件会将 Vue 单文件组件(`.vue` 文件)转换为 JavaScript 模块。
- **代码转换**:Vite 会对源码进行一些必要的转换,例如将 TypeScript 代码转换为 JavaScript 代码,将 JSX 代码转换为普通的 JavaScript 代码等。

### 4. 资源处理

- **静态资源处理**:Vite 会对项目中的静态资源(如图片、字体等)进行处理。它会根据配置将这些资源复制到打包后的目录中,并对引用这些资源的代码进行相应的替换。
- **CSS 处理**:对于 CSS 文件,Vite 会将其进行压缩和合并,同时处理 CSS 中的导入语句和 url 引用。

### 5. 打包输出

- **生成构建产物**:经过前面的处理后,Vite 会将所有的模块和资源打包成最终的构建产物。默认情况下,构建产物会输出到 `dist` 目录下。
- **生成 HTML 文件**:Vite 会根据项目的入口文件生成一个或多个 HTML 文件,这些 HTML 文件会自动引入打包后的 JavaScript 和 CSS 文件。
- **生产环境优化**:在打包过程中,Vite 会对代码进行压缩和混淆,去除不必要的代码和注释,以减小文件体积,提高应用的加载速度。

### 6. 清理与完成

- **清理临时文件**:打包完成后,Vite 会清理在打包过程中生成的临时文件和缓存。
- **输出构建信息**:最后,Vite 会输出构建的相关信息,如构建时间、输出文件的大小等,让开发者了解打包的结果。

综上所述,Vite 在 Vue 应用中的打包过程是一个复杂而高效的流程,通过依赖预构建、源码转换、资源处理等步骤,将项目源码打包成适合生产环境部署的静态文件。

## 6. 为什么 vite 比 webpack 快

Vite 相比 Webpack 更快,主要体现在开发环境的启动速度和热更新速度上,这得益于它在设计理念、打包机制等方面的优势,下面为你详细分析:

### 1. 开发环境启动速度

#### Vite

- **基于原生 ES 模块**:Vite 利用现代浏览器对原生 ES 模块(ES Modules)的支持,无需对项目进行预先打包。当启动开发服务器时,Vite 服务器会直接将项目文件以 ES 模块的形式提供给浏览器。浏览器在请求模块时,Vite 才会按需对模块进行编译和转换。例如,当你启动一个 Vue 项目时,Vite 会快速启动服务器,等待浏览器请求各个模块,而不是像 Webpack 那样先对整个项目进行打包。
- **依赖预构建**:Vite 会对项目中的依赖进行预构建,将 `node_modules` 中的依赖打包成 ES 模块格式。这样做可以将 CommonJS 或 UMD 格式的依赖转换为浏览器可以直接使用的 ES 模块,同时还能对依赖进行优化和缓存。下次启动开发服务器时,如果依赖没有变化,Vite 可以直接使用缓存,从而大大加快启动速度。

#### Webpack

- **全量打包构建**:Webpack 在启动开发服务器时,需要先对整个项目进行打包构建。它会递归解析项目中的所有模块依赖,构建出一个完整的依赖图,然后将所有模块打包到一个或多个 bundle 文件中。这个过程需要消耗大量的时间,尤其是对于大型项目,随着项目规模的增大,打包时间会显著增加。

### 2. 热更新速度

#### Vite

- **按需更新**:当代码发生变化时,Vite 能够精确地找出发生变化的模块,并只对这些模块进行重新编译和更新。由于 Vite 是基于 ES 模块的,它可以直接在浏览器中更新变化的模块,而不需要像 Webpack 那样重新打包整个模块或模块组。这种按需更新的方式使得热更新速度极快,几乎可以达到实时更新的效果。
- **轻量级更新**:Vite 的热更新过程中,只需要更新变化的模块内容,而不需要重新加载整个页面。它通过浏览器的 HMR(Hot Module Replacement)机制,在不刷新页面的情况下更新模块,保留了页面的状态,提高了开发效率。

#### Webpack

- **重新打包部分模块**:Webpack 的热更新机制需要重新打包发生变化的模块及其相关依赖。虽然 Webpack 也有一些优化手段,如缓存和增量编译,但由于其打包机制的复杂性,重新打包的过程仍然需要一定的时间。在某些情况下,可能还需要刷新整个页面,导致热更新速度较慢。

### 3. 配置和处理复杂度

#### Vite

- **简单配置**:Vite 的配置相对简单,很多功能都有默认配置,开箱即用。开发者只需要进行少量的配置就能满足大多数项目的需求。简单的配置意味着更少的处理逻辑和更快的启动速度。
- **高效处理**:Vite 在处理模块时,采用了更高效的方式。例如,它对 Vue 单文件组件的处理更加直接和高效,减少了不必要的中间步骤。

#### Webpack

- **复杂配置**:Webpack 的配置较为复杂,需要开发者手动配置 loader、plugin 等。大量的配置项和复杂的配置逻辑会增加处理时间,尤其是在启动和热更新时,需要重新解析和应用配置。
- **多层处理**:Webpack 在处理模块时,需要经过多个 loader 和 plugin 的处理,这会增加处理的复杂度和时间。例如,一个 `.vue` 文件可能需要经过 `vue-loader`、`babel-loader` 等多个 loader 的处理才能被浏览器识别。
